from connect import Connect, MyHTTPSHandler
from config import Config
import urllib
import urllib2
#import re
#from lxml import etree
import json
from datetime import datetime
from settings import *
from shutil import move
import socket
import os

class Pulllist:
    '''
    Returns pulllist information
    '''
    def __init__(self, useTestData = True):
        #print 'pulllist useTestData', useTestData
        self.service = 'circulation' # WMS Circulation API
        self.resource = 'pulllist'   # API resource
        self.config = Config(service = self.service, useTestData = useTestData)
        self.institution = self.config.getInstitutionData()
        self.serviceAPI = self.config.getServiceAPIData()
 
        self.institutionList = self.institution.get('institution')
        self.branchList = self.institution.get('branch')
        
        self.resourceList = self.serviceAPI.get('%s.%s' % (self.service, self.resource))
        
    def open(self, **kwargs):
        '''
        Dispatch to the requested method
        arguments
        method: describes the method to perform (e.g. read)
        institution: name of the institute (e.g. nltud)
        branch: name of the instute branch (e.g. central_library)
        pending: optional, selects if pending slips are requested.
        apiParam: params givin in the original URL (e.g. itemsPerPage)
        '''
        try:
            method = kwargs['method']
            institution = kwargs['institution']
            branch = kwargs['branch']
            pending = ''
            if kwargs.has_key('pending'):
                pending = kwargs['pending']
            apiParam = kwargs['apiParam']
            _method = getattr(self, method)
            return _method(institution = institution, branch = branch, pending = pending, apiParam = apiParam)
        except Exception, inst:
            raise Exception('Method %s not implemented, use an implemented method or implement this method in %s' % (method, self.__class__.__name__))
        
    def read(self, institution = None, branch = None, pending = None, apiParam = ''):
        '''
        The dispatched method (see 'open')
        '''
        request_url = ''
        datacenter_id = ''
        institution_id = institution
        branch_id = branch
        pending = pending
        
        try:
            for key, value in self.resourceList:
                if key == 'read':
                    request_url = value
                    break
                
            for key, value in self.institutionList:
                if key == 'datacenter':
                    datacenter_id = value
                if key == institution:
                    institution_id = value
    
            for key, value in self.branchList:
                if key == branch:
                    branch_id = value
                    break
        except Exception, inst:
            print inst
            
        request_url = request_url.replace('{datacenter}', datacenter_id)
        request_url = request_url.replace('{branchID}', branch_id)
        if len(apiParam) > 0:
            if request_url.find('?') > -1:
                request_url = '%s&%s' % (request_url, apiParam)
            else:
                request_url = '%s?%s' % (request_url, apiParam)
            

        #print 'request_url', request_url
        response = self._getResponse(institution_id = institution_id, request_url = request_url)
        try:
            filter = FilterPulllist(data = response, config = self.config, branchId = branch_id, pending = pending)
            response = filter.getFilteredData()
        except Exception, inst:
            response = inst 
        return response
        #return self._getResponse(institution_id = institution_id)
        
        
    def _getResponse(self, institution_id = None, request_url = ''):
        connect = Connect(institution_id = institution_id, request_url = request_url, config = self.config)
        opener = urllib2.build_opener(MyHTTPSHandler)
        opener.addheaders = [('accept', 'application/json'),('Authorization', connect.getAuthorization_header())]
        response = opener.open(request_url).read()
        return response


class FilterPulllist:
    '''
    Filters the items needed from the API response
    For getting holding data for serials an extra call is made
    '''
    def __init__(self, data = None, config = None, branchId = None, pending = None):
        self.data = self.getJSON(data)
        self.config = config
        self.branchId = branchId
        self.pending = pending
        self.items = ('requestDate', 
                      'requestTime', 
                      'author',
                      'title',
                      'edition',
                      'barcode',
                      'freeText',
                      'callNumber',
                      'subLibrary',
                      'itemStatus',
                      'requestFor',
                      'recordType',
                      'hotspotRequestFor',
                      'hotspotRequestDate',
                      'status',
                      'pickupLocation',
                      'doubleCheck',
                      'deltaRecordType',   # guesses if an item is a SERIAL
                      'oclcNumber',        # sets holding information in self.holdingData, MUST be set in order for holding information
                  #    'holdingISSN',
                      'holdingCallNumber',
                  #    'holdingArticleTitle',
                  #    'holdingArticleAuthor',
                  #    'holdingYear',
                  #    'holdingVolume',
                  #    'holdingIssue',
                  #    'holdingFirstPage',
                     )

        self.filteredData = {}
        self.holdingData = {}  # extra holdinginformation via the collection manager API with oclcNumber as key
        self.getResult(data = self.data)

    def getResult(self, data = None):
        '''
        Creates a dictionary with a key 'data' that contains the filtered result and a key 'message' that contains a ... (yes!)
        Keeps track of pending files for each branch
        '''
        # start getting branchname
        branchList = self.config.getInstitutionData()['branch']
        branchName = ""
        for value, key in branchList:
            if key == self.branchId:
                branchName = value
                break
        # end getting branchname
        pendingFile = '%s/%s_%s%s' % (PENDING_DIR, 'pending', branchName, '.txt')
        result = [] 
        resultCurrent = []
        resultPending = []
        previousPendingFileList = []
        newPreviousPendingFileList = []
        pendingDataDict = {}
        if data.has_key('entry'):
            # start get previous file
            
            try:
                previousFile = open(pendingFile, 'r')
                previousPendingFileList = previousFile.read().splitlines()
                previousFile.close()
            except Exception, inst:
                print inst
                pass
            # end get previous file
           
            for record in data.get('entry'):
                # start getting serial holding data
                #self.holdingData = self.getHoldingData()
                # end getting serial holding data
                slip = {}
                # is initialisation optional?
                for item in self.items:
                    slip[item] = 'x'
            
                for item in self.items:
                    slip[item] = self._do(method = item, record = record)
                    #print 'slip;', slip

                # start create new pendingDataDict with current data
                if slip.has_key('doubleCheck'):
                    pendingDataDict[slip.get('doubleCheck')] = slip 
                # end create new previousDataDict with current data
 
            if self.pending:
                # results in a list with records in BOTH files/recordlists: pendingDataDict AND previousPendingFileList
                # results in pending slips
                for pendingItem in previousPendingFileList:
                    if pendingDataDict.has_key(pendingItem):                   # presence in BOTH 
                        newPreviousPendingFileList.append(pendingItem)         # contains keys
                        resultPending.append(pendingDataDict.get(pendingItem)) # contains slip data
            else:
                # results in a new previous list with records from the previousPendingFile AND records from the pendingDataDict
                # results in new slips
                for pendingItem in previousPendingFileList:
                    if pendingDataDict.has_key(pendingItem):
                        newPreviousPendingFileList.append(pendingItem)         # contains key

                for pendingItem in pendingDataDict.keys():
                    if pendingItem not in newPreviousPendingFileList:
                        newPreviousPendingFileList.append(pendingItem)         # contains key
                        resultCurrent.append(pendingDataDict.get(pendingItem)) # contains a slip 

            if self.pending:
                result = resultPending
            else:
                result = resultCurrent
                

            # start writing new previous filelist
            try:
                # write to a file with extension .tmp and than use shutil.move(src, dst)  (import shutil) leads to a unary operation
                tmpFile = '%s%s' % (pendingFile, '.tmp')
                previousFile = open(tmpFile, 'w')
                for key in newPreviousPendingFileList:
                    previousFile.write('%s\n' % key)
                previousFile.close()
                move(tmpFile, pendingFile)
            except Exception, inst:
                print inst
                pass
            
            # end writing new previous filelist

        self.filteredData['data'] = result
        print 'result len', len(result)
        if len(result) == 0:
            self.filteredData['message'] = 'No data found'
        else:
            if len(result) > 1:
                s = 's'
            else:
                s = ''
            self.filteredData['message'] = '%s %s %s%s' % ('Found', len(result), 'item', s)

        return True

    def getFilteredData(self):
        '''
        returns the filtered data as a dictionary
        {'data': <data>, 'message': <message>}
        '''

        return self.filteredData

    def getJSON(self, data):
        try:
            data = json.loads(data)
            return data
        except Exception, inst:
            print inst
        
    def _do(self, method = None, record = None):
        '''
        Dispatch to the requested method
        '''
        try:
            methodName = '%s%s%s' % ('_get', method[0].capitalize(), method[1:])
            method = getattr(self, methodName)
        except Exception, inst:
            print 'inst',inst
            raise Exception('Method %s not implemented, use an implemented method or implement this method in %s' % (method, self.__class__.__name__))
        return method(record)

    def getHoldingResult(self, oclcNumber = None):
        hostname = socket.gethostname()
        print hostname
        url = 'http://%s/worldcat/holding/search/?oclcnumber=%s' % (hostname, oclcNumber)
        #url = 'http://%s/worldcat/availability/read/?oclcnumber=%s' % (hostname, oclcNumber)
        #url = 'http://localhost/worldcat/holding/search/?oclcnumber=%s' % oclcNumber
        #url = http://handlero.tudelft.nl/worldcat/holding/search/?oclcnumber=11294462
        print url
        response = urllib.urlopen(url);
        data = response.read()
        data = json.loads(data)
        #print type(data)
        return data

    def _getHoldingCallNumber(self, record):
        try:
            callNumber = self.holdingData.get('response').get('data')[0].get('callNumber')
            return callNumber
        except Exception, inst:
            print inst
            return 'Unknown'

    def _getHoldingISSN(self, record):
        try:
            issn = self.holdingData.get('issn')
            return issn
        except:
            return 'Unknown'

    def _getHoldingArticleTitle(self, record):
        try:
            articleTitle = self.holdingData.get('response').get('data')[0].get('articleTitle')
            return articleTitle 
        except Exception, inst:
            print inst
            return 'Unknown'

    def _getHoldingArticleAuthor(self, record):
        try:
            articleAuthor = self.holdingData.get('???')
            return articleAuthor
        except:
            return 'Unknown'

    def _getHoldingYear(self, record):
        try:
            year= self.holdingData.get('???')
            return year
        except:
            return 'Unknown'

    def _getHoldingVolume(self, record):
        try:
            volume = self.holdingData.get('???')
            return volume
        except:
            return 'Unknown'

    def _getHoldingIssue(self, record):
        try:
            issue = self.holdingData.get('???')
            return issue
        except:
            return 'Unknown'

    def _getHoldingFirstPage(self, record):
        try:
            firstPage = self.holdingData.get('???')
            return firstPage
        except:
            return 'Unknown'

    def _getDoubleCheck(self, record):
        '''
        Result of this method is used to identify a pending slip request
        The combination requestDate and oclcNumber seems to be unique and can thus be used for this purpose
        '''
        try:
            oclcNumber = record.get('bibliographicItem').get('oclcNumber')
            requestDate = record.get('requestDate')
            return '%s %s' % (requestDate, oclcNumber)
        except:
            return ''

    def _getDeltaRecordType(self, record):
        '''
        Result of this methos is to determine if an item is a Serial
        If recordType == 'SERIAL' is it is obvious
        If the barcode contains a $ it is probably a SERIAL
        '''
        try:
            recordType = record.get('recordType')
            barcode = record.get('pieceDesignation')
            if (recordType == 'SERIAL' or barcode.find('$') > -1):
                return 'SERIAL'
        except Exception, inst:
            print inst
            return 'Unknown'

    def _getOclcNumber(self, record):
        '''
        In case of a SERIAL another method is called in order to get holding information for serials
        '''
        try:
            oclcNumber = record.get('bibliographicItem').get('oclcNumber')
            if self._getDeltaRecordType(record) == 'SERIAL':
                # get holding Data through another API
                self.holdingData = self.getHoldingResult(oclcNumber = oclcNumber)
            return oclcNumber
        except Exception, inst:
            print '_getOclcNumber', inst
            return 'Unknown'

    def _getFreeText(self, record):
        try:
            freeText = record.get('freeText')
            return freeText
        except:
            return 'Unknown'

    def _getRequestDate(self, record):
        try:
            requestDate = record.get('requestDate')
            requestDateObj = datetime.utcfromtimestamp(requestDate/1000)
            return requestDateObj.strftime('%d/%m/%Y')
            # xml geeft: <ns2:requestDate>2014-10-29T16:13:49.000Z</ns2:requestDate>
        except:
            return 'Unknown'
  
    def _getHotspotRequestDate(self, record):
        try:
            requestDate = record.get('requestDate')
            requestDateObj = datetime.utcfromtimestamp(requestDate/1000)
            return requestDateObj.strftime('%d/%m/%Y')
            # xml geeft: <ns2:requestDate>2014-10-29T16:13:49.000Z</ns2:requestDate>
        except:
            return 'Unknown'
  
    def _getRequestTime(self, record):
        try:
            requestDate = record.get('requestDate')
            requestDateObj = datetime.utcfromtimestamp(requestDate/1000)
            return requestDateObj.strftime('%H:%M')
            # xml geeft: <ns2:requestDate>2014-10-29T16:13:49.000Z</ns2:requestDate>
        except:
            return 'Unknown'

                #return 'No more pending pickup slips, you worked hard! Time to relax'

    def _getAuthor(self, record):
        try:
            result = record.get('bibliographicItem').get('author')
            return result
        except:
            return 'Unknown'

    def _getTitle(self, record):
        try:
            max = 120
            result = record.get('bibliographicItem').get('title')
            if len(result) > max:
               result = '%s ...' % result[:max]
            return result
        except:
            return 'Unknown'

    def _getEdition(self, record):
        try:
            result = record.get('bibliographicItem').get('edition')
            return result
        except:
            return 'Unknown'

    def _getBarcode(self, record):
        try:
            result = record.get('pieceDesignation')
            return result
        except:
            return 'Unknown'

    def _getCallNumber(self, record):
        try:
            result = record.get('callNumber').get('description')
            return result
        except:
            return 'Unknown'

    def _getRecordType(self, record):
        try:
            result = record.get('recordType')
            return result
        except:
            return 'Unknown'

    def _getSubLibrary(self, record):
        try:
            institutionData = self.config.getInstitutionData()
            for branchList in institutionData['branch']:
                if self.branchId in branchList:
                    result = branchList[0]  
                    break
            return result
        except:
            return 'Unknown'

    def _getItemStatus(self, record):
        try:
            result = record.get('?????')
            return result or '?????'
        except:
            return 'Unknown'

    def _getRequestFor(self, record):
        try:
            result = record.get('patronName')
            return result
        except:
            return 'Unknown'

    def _getHotspotRequestFor(self, record):
        try:
            result = record.get('patronName')
            return result
        except:
            return 'Unknown'

    def _getStatus(self, record):
        try:
            result = record.get('?????')
            return result or '?????'
        except:
            return 'Unknown'

    def _getPickupLocation(self, record):
        try:
            pass
            result = 'Nog niet bekend'
            #institutionData = self.config.getInstitutionData()
            #for branchList in institutionData['branch']:
            #    if self.branchId in branchList:
            #        result = branchList[0]
            #        break
            return result
        except:
            return 'Unknown'
        pass


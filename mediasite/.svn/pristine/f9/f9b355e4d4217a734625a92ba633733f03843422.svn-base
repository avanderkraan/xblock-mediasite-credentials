from connect import Connect, MyHTTPSHandler
from config import Config
import urllib2
import re
from lxml import etree
import json
#from datetime import datetime
from settings import *

class Availability:
    '''
    Returns availability information
    '''
    def __init__(self, useTestData = True):
        print 'availability', 'opacrecord'
        self.service = 'availability' # WMS Availability API
        self.resource = 'opacrecord'   # API resource
        self.config = Config(service = self.service, useTestData = useTestData)
        self.institution = self.config.getInstitutionData()
        self.serviceAPI = self.config.getServiceAPIData()
 
        self.institutionList = self.institution.get('institution')
        
        self.resourceList = self.serviceAPI.get('%s.%s' % (self.service, self.resource))
        
    def open(self, **kwargs):
        '''
        Dispatch to the requested method
        arguments
        method: describes the method to perform (e.g. read)
        institution: name of the institute (e.g. nltud)
        oclcNumber: identifies the holding article
        apiParam: params givin in the original URL (e.g. itemsPerPage)
        '''
        try:
            method = kwargs['method']
            institution = kwargs['institution']
            oclcNumber = kwargs['oclcNumber']
            apiParam = kwargs['apiParam']
            _method = getattr(self, method)
            return _method(institution = institution, oclcNumber = oclcNumber, apiParam = apiParam)
        except Exception, inst:
            print inst
            raise Exception('Method %s not implemented, use an implemented method or implement this method in %s' % (method, self.__class__.__name__))
        
    def read(self, institution = None, oclcNumber = None, apiParam = ''):
        '''
        The dispatched method (see 'open')
        '''
        request_url = ''
        institution_id = institution
        try:
            for key, value in self.resourceList:
                if key == 'read':
                    request_url = value
                    break
                
            for key, value in self.institutionList:
                if key == institution:
                    institution_id = value
    
        except Exception, inst:
            print inst
            

        request_url = request_url.replace('{institutionRegistryID}', institution_id)
        request_url = request_url.replace('{oclcNumber}', oclcNumber)
        if len(apiParam) > 0:
            if request_url.find('?') > -1:
                request_url = '%s&%s' % (request_url, apiParam)
            else:
                request_url = '%s?%s' % (request_url, apiParam)
            
        print 'request_url', request_url
        response = self._getResponse(institution_id = institution_id, request_url = request_url)
        #response = self.filterXML(response)
        try:
            filter = FilterAvailability(data = response, config = self.config, oclcNumber = oclcNumber)
            response = filter.getFilteredData()
        except Exception, inst:
            print inst
            response = inst 
        return response
        #return self._getResponse(institution_id = institution_id)
        
        
    def _getResponse(self, institution_id = None, request_url = ''):
        try:
            connect = Connect(institution_id = institution_id, request_url = request_url, config = self.config)
            opener = urllib2.build_opener(MyHTTPSHandler)
            opener.addheaders = [('accept', 'application/sru+xml'),('Authorization', connect.getAuthorization_header())]
            response = opener.open(request_url).read()
            return response
        except Exception, inst:
            print inst
        return False

class FilterAvailability:
    '''
    Filters the items needed from the API response
    This data is in XML format
    '''
    def __init__(self, data = None, config = None, oclcNumber = None):
        
        self.data = self.getXMLRecords(data)
        self.namespaces = self.getNamespaces()
        self.config = config
        self.items = (#'articleTitle',
                      'callNumber',
                     # 'articleAuthor',
                     # 'year',
                     # 'volume',
                     # 'issue',
                     # 'firstPage',
                     )
        self.filteredData = {}
        self.getResult(data = self.data)

    def getResult(self, data = None):
        '''
        Creates a dictionary with a key 'data' that contains the filtered result and a key 'message' that contains a ... (yes!)
        '''
        result = [] 
        if len(data) > 0:
            #print 'len', len(data)
            for record in data:
                slip = {}
                # is initialisation optional?
                for item in self.items:
                    slip[item] = 'x'
            
                for item in self.items:
                    slip[item] = self._do(method = item, record = record)

                #print item, record
                result.append(slip)

        self.filteredData['data'] = result

        if len(result) == 0:
            self.filteredData['message'] = 'No data found'
        else:
            if len(result) > 1:
                s = 's'
            else:
                s = ''
            self.filteredData['message'] = '%s %s %s%s' % ('Found', len(result), 'item', s)

        return True

    def getFilteredData(self):
        '''
        returns the filtered data as a dictionary
        {'data': <data>, 'message': <message>}
        '''
        return self.filteredData

    def getNamespaces(self):
        namespaces = {
          'ns2': 'http://www.loc.gov/zing/cql/xcql/',
          'ns3': 'http://www.loc.gov/zing/srw/diagnostic/',
          'ns4': 'http://www.loc.gov/zing/srw/update/'
        }
        return namespaces

    def getXMLRecords(self, data):
        '''
        Returns a list of etree Elements
        '''
        try:
            data = re.sub(' xmlns="[^"]+"', '', data, count=1)   # remove the empty namespace
            parser = etree.XMLParser(recover=True)
        
            elementRoot = etree.fromstring(data, parser)
            records = elementRoot.findall('records')
            return records
        except Exception, inst:
            print inst
        
    def _do(self, method = None, record = None):
        '''
        Dispatch to the requested method
        '''
        try:
            methodName = '%s%s%s' % ('_get', method[0].capitalize(), method[1:])
            method = getattr(self, methodName)
        except Exception, inst:
            print 'ppp', inst
            raise Exception('Method %s not implemented, use an implemented method or implement this method in %s' % (method, self.__class__.__name__))
        return method(record)

    def _getArticleTitle(self, record):
        try:
            articleTitleList = record.xpath('//subfield[@code="245"]', namespaces = self.namespaces)
            articleTitle = articleTitleList[0].text
            return articleTitle
        except:
            return 'Unknown'

    def _getCallNumber(self, record):
        try:
            callNumberList = record.xpath('//callNumber', namespaces = self.namespaces)
            callNumber = callNumberList[0].text
            return callNumber 
        except:
            return 'Unknown'

